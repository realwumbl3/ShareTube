{% extends 'dashboard/base.html' %}
{% set title = 'ShareTube Ops · Rooms' %}
{% block head %}
<style>
  .rooms {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(360px, 1fr));
    gap: 16px;
  }

  .room {
    padding: 14px;
    position: relative;
    overflow: hidden;
  }

  .room:before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(400px 200px at 110% -20%, rgba(124, 58, 237, .12), transparent 60%);
    pointer-events: none;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }

  .left .label {
    color: var(--fg-dim);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: .7px;
  }

  .left code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background: rgba(124, 58, 237, .12);
    color: #C8B6FF;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid rgba(124, 58, 237, .35);
  }

  .pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 12px;
    letter-spacing: .3px;
    border: 1px solid var(--border);
  }

  .pill.playing {
    background: rgba(34, 197, 94, .12);
    color: #b7f7c9;
    border-color: rgba(34, 197, 94, .35);
  }

  .pill.starting {
    background: rgba(59, 130, 246, .16);
    color: #cbe1ff;
    border-color: rgba(59, 130, 246, .35);
  }

  .pill.idle {
    background: rgba(100, 116, 139, .16);
    color: #cbd5e1;
    border-color: rgba(100, 116, 139, .35);
  }

  .pill.playing_ad {
    background: rgba(234, 88, 12, .18);
    color: #ffd1b3;
    border-color: rgba(234, 88, 12, .45);
  }

  .users {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .user {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 8px;
    background: var(--panel-2);
    border: 1px solid var(--border);
    border-radius: 999px;
    transition: background-color .15s ease, border-color .15s ease;
  }

  .avatar {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    color: #0b0f14;
    background: linear-gradient(135deg, #a78bfa, #34d399);
    border: 1px solid rgba(255, 255, 255, .2);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .06);
  }

  .name {
    font-weight: 600;
    font-size: 12px;
  }

  .state {
    display: none;
  }

  .icon {
    font-size: 12px;
    line-height: 1;
  }

  .flag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--fg-dim);
  }

  .flag.ad {
    background: rgba(234, 88, 12, .18);
    color: #ffd1b3;
    border-color: rgba(234, 88, 12, .45);
  }

  .user.playing {
    background: rgba(34, 197, 94, .12);
    border-color: rgba(34, 197, 94, .35);
  }

  .user.idle {
    background: rgba(59, 130, 246, .16);
    border-color: rgba(59, 130, 246, .35);
  }

  .user.paused {
    background: rgba(100, 116, 139, .16);
    border-color: rgba(100, 116, 139, .35);
  }

  .user.ad {
    background: rgba(234, 88, 12, .12);
    border-color: rgba(234, 88, 12, .35);
  }

  .icon.playing {
    color: #b7f7c9;
  }

  .icon.idle {
    color: #cbe1ff;
  }

  .icon.paused {
    color: #cbd5e1;
  }

  .icon.ad {
    color: #ffd1b3;
  }

  .badge {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--fg-dim);
  }

  .badge.playing {
    background: rgba(34, 197, 94, .12);
    color: #b7f7c9;
    border-color: rgba(34, 197, 94, .35);
  }

  .badge.idle {
    background: rgba(100, 116, 139, .16);
    color: #cbd5e1;
    border-color: rgba(100, 116, 139, .35);
  }

  .badge.ad {
    background: rgba(234, 88, 12, .18);
    color: #ffd1b3;
    border-color: rgba(234, 88, 12, .45);
  }

  .state.active {
    color: #a7f3d0;
  }

  .metaRow {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }

  .chip {
    font-size: 11px;
    color: var(--fg-dim);
    padding: 6px 10px;
    border: 1px solid var(--border);
    border-radius: 999px;
    background: var(--panel-2);
  }

  .queue {
    margin-top: 12px;
    overflow-y: auto;
    max-height: 330px;
    padding-right: 5px;
  }

  .entry {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: var(--panel);
  }

  .entry+.entry {
    margin-top: 6px;
  }

  .thumb {
    width: 64px;
    height: 36px;
    background: #111;
    border-radius: 6px;
    object-fit: cover;
    border: 1px solid var(--border);
  }

  .entryTitle {
    font-weight: 600;
  }

  .entryUrl {
    font-size: 12px;
    color: var(--fg-dim);
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }

  .queueHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin: 8px 0;
  }

  .queueHeader .label {
    font-size: 12px;
    color: var(--fg-dim);
  }

  .controls .btn {
    margin-left: 6px;
    padding: 4px 8px;
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--fg);
    border-radius: 8px;
    cursor: pointer;
  }

  .playerBar {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 6px 0 10px 0;
  }

  .playerBar .time {
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    color: var(--fg-dim);
    width: 64px;
    text-align: right;
  }

  .playerBar input[type="range"] {
    flex: 1 1 auto;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 999px;
    outline: none;
  }

  .playerBar input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #a78bfa;
    border: 1px solid rgba(255, 255, 255, .4);
  }

  .tabs {
    display: flex;
    gap: 8px;
    margin-top: 12px;
    border-bottom: 1px solid var(--border);
  }

  .tab {
    appearance: none;
    border: none;
    background: transparent;
    color: var(--fg-dim);
    font-size: 12px;
    padding: 8px 10px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
  }

  .tab.active {
    color: var(--fg);
    border-color: var(--fg);
  }

  .tabContent {
    margin-top: 8px;
  }

  .audit {
    margin-top: 12px;
    overflow-y: auto;
    max-height: 330px;
    padding-right: 5px;
  }

  .auditItem {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: var(--panel);
  }

  .auditItem+.auditItem {
    margin-top: 6px;
  }

  .auditTime {
    font-size: 11px;
    color: var(--fg-dim);
    white-space: nowrap;
  }

  .auditText {
    font-size: 13px;
  }
</style>
{% endblock %}
{% block subright %}
<div id="authBox" style="display:flex; align-items:center; gap:8px;">
  <img id="authAvatar" src="" alt="" style="width:24px; height:24px; border-radius:50%; display:none; border:1px solid var(--border);" />
  <span id="authName" style="font-size:12px; color: var(--fg-dim); display:none;"></span>
  <button id="signInBtn" type="button" style="padding:6px 10px; border:1px solid var(--border); background: var(--panel-2); color:var(--fg); border-radius:10px; cursor:pointer;">Sign in</button>
  <button id="signOutBtn" type="button" style="padding:6px 10px; border:1px solid var(--border); background: var(--panel-2); color:var(--fg); border-radius:10px; cursor:pointer; display:none;">Sign out</button>
  <span id="opsBadge" class="chip" style="display:none;">Monitoring</span>
  <span id="authError" class="chip" style="display:none; color:#fca5a5; border-color:rgba(239, 68, 68, .45);">Auth error</span>
  <span id="authBusy" class="chip" style="display:none;">Signing in…</span>
  <script>
    (function(){
      function setIdentityUI(user, isOps){
        try {
          const avatar = document.getElementById('authAvatar');
          const name = document.getElementById('authName');
          const inBtn = document.getElementById('signInBtn');
          const outBtn = document.getElementById('signOutBtn');
          const ops = document.getElementById('opsBadge');
          const busy = document.getElementById('authBusy');
          const err = document.getElementById('authError');
          if (!avatar || !name || !inBtn || !outBtn || !ops) return;
          err.style.display = 'none';
          busy.style.display = 'none';
          const hasUser = !!(user && (user.name || user.picture));
          if (hasUser){
            const nm = String(user.name || '').trim();
            if (user.picture){ avatar.src = user.picture; avatar.style.display = ''; } else { avatar.style.display = 'none'; }
            name.textContent = nm || 'Signed in';
            name.style.display = nm ? '' : 'none';
            inBtn.style.display = 'none';
            outBtn.style.display = '';
            ops.style.display = 'none';
          } else {
            avatar.style.display = 'none';
            name.style.display = 'none';
            outBtn.style.display = 'none';
            inBtn.style.display = '';
            ops.style.display = isOps ? '' : 'none';
          }
        } catch {}
      }
      function setupAuthButtons(){
        try {
          const inBtn = document.getElementById('signInBtn');
          const outBtn = document.getElementById('signOutBtn');
          const busy = document.getElementById('authBusy');
          const err = document.getElementById('authError');
          if (inBtn){
            inBtn.addEventListener('click', function(){
              try {
                err.style.display = 'none';
                busy.style.display = '';
                const w = window.open('/auth/google/start', 'oauth', 'width=500,height=650');
                function onMsg(ev){
                  try {
                    const data = ev.data || {};
                    if (data && data.type === 'newapp_auth' && data.token){
                      localStorage.setItem('dash_token', data.token);
                      window.removeEventListener('message', onMsg);
                      location.href = location.pathname; // drop any token query
                    }
                  } catch {}
                }
                window.addEventListener('message', onMsg);
                const timer = setInterval(function(){
                  try { if (w && w.closed){ clearInterval(timer); busy.style.display = 'none'; } } catch {}
                }, 500);
              } catch { busy.style.display = 'none'; err.style.display = ''; }
            });
          }
          if (outBtn){
            outBtn.addEventListener('click', function(){
              try { localStorage.removeItem('dash_token'); } catch {}
              location.href = location.pathname;
            });
          }
        } catch {}
      }
      // Expose to page script
      window.__setIdentityUI = setIdentityUI;
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setupAuthButtons); else setupAuthButtons();
    })();
  </script>
</div>
{% endblock %}
{% block content %}
<div class="layout">
  <div class="panel sidebar">
    <div class="chip" style="margin:8px 0 10px 0; display:inline-block;">Active rooms</div>
    <div class="roomsList" id="sidebarRooms"></div>
  </div>
  <div>
    <div class="metaRow">
      <div class="chip">Real‑time rooms & presence</div>
      <div class="chip">Socket.IO live feed</div>
      <input id="roomCodeInput" type="text" placeholder="Enter room code"
        style="flex:0 0 280px; padding:6px 10px; border:1px solid var(--border); background: var(--panel-2); color: var(--fg); border-radius: 10px;" />
      <button id="roomAddBtn" class="btn" type="button"
        style="padding:6px 10px; border:1px solid var(--border); background: var(--panel-2); color:var(--fg); border-radius:10px; cursor:pointer;">Add
        room</button>
    </div>
    <div id="rooms" class="rooms"></div>
  </div>
</div>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"
  integrity="sha384-mZLF4UVrpi/QTWPA7BjNPEnkIfRFn4ZEO3Qt/HFklTJBj/gBOV8G3HcKn4NfQblz" crossorigin="anonymous"></script>
<script>
  function getInitials(name) {
    const n = (name || '').trim();
    if (!n) return '?';
    // If contains spaces, use first letters of first two words
    const parts = n.split(/\s+/).filter(Boolean);
    if (parts.length >= 2) {
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }
    // CamelCase or multiple capitals in one word
    const caps = (n.match(/[A-Z]/g) || []);
    if (caps.length >= 2) {
      return (caps[0] + caps[1]).toUpperCase();
    }
    // Fallback: first two characters
    const s = n.slice(0, 2).toUpperCase();
    return s.padEnd(2, s[0] || '?');
  }

  // Incremental rendering helpers
  function setText(el, text) { if (el && el.textContent !== text) el.textContent = text; }
  function setClass(el, cls) { if (el && el.className !== cls) el.className = cls; }

  function upsertRoomCard(container, room) {
    let card = document.getElementById('room-' + room.code);
    if (!card) {
      card = document.createElement('div');
      card.className = 'panel room';
      card.id = 'room-' + room.code;
      card.dataset.code = room.code;

      const header = document.createElement('div'); header.className = 'header';
      const left = document.createElement('div'); left.className = 'left';
      left.innerHTML = '<div class="label">Room</div><div style="margin-top:4px"><code>' + room.code + '</code></div>';
      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.alignItems = 'center';
      right.style.justifyContent = 'center';
      right.style.gap = '8px';
      const pill = document.createElement('span'); pill.className = 'pill'; pill.dataset.role = 'pill';
      const rbtn = document.createElement('button'); rbtn.type = 'button'; rbtn.className = 'btn';
      rbtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path><path d="M21 12a9 9 0 1 0-9 9 9.75 9.75 0 0 0 6.74-2.74l0 0"></path></svg>';
      rbtn.style.unset = 'all';
      rbtn.style.padding = '4px';
      rbtn.style.borderRadius = '8px';
      rbtn.style.border = '1px solid var(--border)';
      rbtn.style.background = 'var(--panel-2)';
      rbtn.style.color = 'var(--fg)';
      rbtn.style.cursor = 'pointer';
      rbtn.style.transition = 'all 0.15s ease';
      rbtn.style.display = 'flex';
      rbtn.style.alignItems = 'center';
      rbtn.style.justifyContent = 'center';
      rbtn.addEventListener('click', () => { try { if (window.refreshRoom) window.refreshRoom(card.dataset.code); } catch { } });
      right.appendChild(pill); right.appendChild(rbtn);
      header.appendChild(left); header.appendChild(right); card.appendChild(header);

      const users = document.createElement('div'); users.className = 'users'; users.dataset.role = 'users';
      card.appendChild(users);

      const tabs = document.createElement('div'); tabs.className = 'tabs';
      const tabQueue = document.createElement('button'); tabQueue.type = 'button'; tabQueue.className = 'tab active'; tabQueue.textContent = 'Queue'; tabQueue.dataset.role = 'tabQueue';
      const tabAudit = document.createElement('button'); tabAudit.type = 'button'; tabAudit.className = 'tab'; tabAudit.textContent = 'Audit'; tabAudit.dataset.role = 'tabAudit';
      tabs.appendChild(tabQueue); tabs.appendChild(tabAudit); card.appendChild(tabs);

      const content = document.createElement('div'); content.className = 'tabContent'; card.appendChild(content);

      const queueWrap = document.createElement('div'); queueWrap.className = 'queue'; queueWrap.dataset.role = 'queue';
      const qHeader = document.createElement('div'); qHeader.className = 'queueHeader';
      const qLabel = document.createElement('div'); qLabel.className = 'label'; qLabel.dataset.role = 'queueLabel';
      const controls = document.createElement('div'); controls.className = 'controls';
      const btnPlay = document.createElement('button'); btnPlay.type = 'button'; btnPlay.textContent = 'Play'; btnPlay.className = 'btn'; btnPlay.addEventListener('click', () => controlRoom(card.dataset.code, 'play'));
      const btnPause = document.createElement('button'); btnPause.type = 'button'; btnPause.textContent = 'Pause'; btnPause.className = 'btn'; btnPause.addEventListener('click', () => controlRoom(card.dataset.code, 'pause'));
      const btnNext = document.createElement('button'); btnNext.type = 'button'; btnNext.textContent = 'Next'; btnNext.className = 'btn'; btnNext.addEventListener('click', () => controlRoom(card.dataset.code, 'next'));
      controls.appendChild(btnPlay); controls.appendChild(btnPause); controls.appendChild(btnNext);
      qHeader.appendChild(qLabel); qHeader.appendChild(controls); queueWrap.appendChild(qHeader);

      const playerBar = document.createElement('div'); playerBar.className = 'playerBar';
      const cur = document.createElement('div'); cur.className = 'time'; cur.dataset.role = 'cur'; cur.textContent = '0:00';
      const range = document.createElement('input'); range.type = 'range'; range.min = '0'; range.max = '1000'; range.step = '1'; range.value = '0'; range.dataset.role = 'seekRange';
      const dur = document.createElement('div'); dur.className = 'time'; dur.dataset.role = 'dur'; dur.textContent = '0:00';
      const setDrag = (v) => { try { range._dragging = !!v; } catch { } };
      range.addEventListener('mousedown', () => setDrag(true));
      range.addEventListener('touchstart', () => setDrag(true));
      range.addEventListener('mouseup', () => setDrag(false));
      range.addEventListener('touchend', () => setDrag(false));
      range.addEventListener('input', () => { const info = range._meta || { dur: 0 }; const ms = Math.floor((Number(range.value || '0') / 1000) * (info.dur || 0)); cur.textContent = fmtTime(ms); });
      range.addEventListener('change', () => { const info = range._meta || { dur: 0 }; const ms = Math.floor((Number(range.value || '0') / 1000) * (info.dur || 0)); const pill = card.querySelector('[data-role="pill"]'); const isPlaying = !!(pill && pill.className && pill.className.indexOf('playing') !== -1 && pill.className.indexOf('playing_ad') === -1); controlRoom(card.dataset.code, 'seek', ms, isPlaying); });
      playerBar.appendChild(cur); playerBar.appendChild(range); playerBar.appendChild(dur);
      queueWrap.appendChild(playerBar);
      content.appendChild(queueWrap);

      const auditWrap = document.createElement('div'); auditWrap.className = 'audit'; auditWrap.dataset.role = 'audit'; auditWrap.style.display = 'none';
      content.appendChild(auditWrap);

      function switchTab(name) {
        const isQueue = name === 'queue';
        tabQueue.classList.toggle('active', isQueue);
        tabAudit.classList.toggle('active', !isQueue);
        queueWrap.style.display = isQueue ? '' : 'none';
        auditWrap.style.display = isQueue ? 'none' : '';
        card.dataset.activeTab = name;
      }
      tabQueue.addEventListener('click', () => switchTab('queue'));
      tabAudit.addEventListener('click', () => switchTab('audit'));
      switchTab('queue');

      container.appendChild(card);
    }
    return card;
  }

  function updateRoomHeader(card, room) {
    const pill = card.querySelector('[data-role="pill"]');
    const raw = String(room.state || 'idle');
    const allowed = new Set(['idle', 'starting', 'playing', 'playing_ad']);
    const state = allowed.has(raw) ? raw : 'idle';
    setClass(pill, 'pill ' + state);
    const label = (state === 'playing') ? 'Playing'
      : (state === 'starting') ? 'Starting'
        : (state === 'playing_ad') ? 'Ads playing'
          : 'Idle';
    setText(pill, label);

    // Update live seek bar from room timing info when available
    const range = card.querySelector('[data-role="seekRange"]');
    const curEl = card.querySelector('[data-role="cur"]');
    const durEl = card.querySelector('[data-role="dur"]');
    const first = Array.isArray(room.entries) && room.entries.length > 0 ? room.entries[0] : null;
    const dur = Number(first && first.duration || 0);
    const prog = Number(first && first.progress || 0);
    const ps = Number(first && first.playing_since || 0);
    const now = Date.now();
    let curMs = prog || 0;
    if (state === 'playing' && ps > 0) {
      curMs = Math.min(dur || Infinity, (prog || 0) + Math.max(0, now - ps));
    }
    if (range) {
      range._meta = { dur: dur, prog: prog, ps: ps };
      const pct = dur > 0 ? Math.max(0, Math.min(1000, Math.floor((curMs / dur) * 1000))) : 0;
      if (!range._dragging) {
        range.value = String(pct);
      }
    }
    if (curEl) curEl.textContent = fmtTime(curMs);
    if (durEl) durEl.textContent = fmtTime(dur);
  }

  function updateUsers(card, room) {
    const usersEl = card.querySelector('[data-role="users"]');
    const users = Array.isArray(room.users) ? room.users : [];
    const present = new Set(users.map(u => String(u.id)));

    // Remove missing
    for (const row of Array.from(usersEl.querySelectorAll('.user'))) {
      if (!present.has(String(row.dataset.userId || ''))) {
        row.remove();
      }
    }

    // Add/update rows
    for (const u of users) {
      let row = usersEl.querySelector('.user[data-user-id="' + String(u.id) + '"]');
      if (!row) {
        row = document.createElement('div'); row.className = 'user'; row.dataset.userId = String(u.id);
        const avatar = document.createElement('div'); avatar.className = 'avatar'; avatar.dataset.role = 'avatar';
        const name = document.createElement('div'); name.className = 'name'; name.dataset.role = 'name';
        const icon = document.createElement('span'); icon.className = 'icon'; icon.dataset.role = 'icon';
        const adflag = document.createElement('span'); adflag.className = 'flag ad'; adflag.textContent = 'AD'; adflag.dataset.role = 'adflag'; adflag.style.display = 'none';
        const state = document.createElement('div'); state.className = 'state'; state.dataset.role = 'state';
        const basic = document.createElement('span'); basic.className = 'basic'; state.appendChild(basic);
        const badge = document.createElement('span'); badge.className = 'badge'; badge.dataset.role = 'badge'; state.appendChild(badge);
        row.appendChild(avatar); row.appendChild(name); row.appendChild(icon); row.appendChild(adflag); row.appendChild(state);
        usersEl.appendChild(row);
      }
      const avatarEl = row.querySelector('[data-role="avatar"]');
      const nameEl = row.querySelector('[data-role="name"]');
      const stateEl = row.querySelector('[data-role="state"]');
      const basicEl = row.querySelector('.basic');
      const badgeEl = row.querySelector('[data-role="badge"]');
      const iconEl = row.querySelector('[data-role="icon"]');
      const adFlagEl = row.querySelector('[data-role="adflag"]');

      setText(avatarEl, getInitials(u.name || ''));
      setText(nameEl, u.name || ('User #' + u.id));
      setClass(stateEl, 'state' + (u.active ? ' active' : ''));
      const basicText = u.active ? 'active' : ('inactive');
      setText(basicEl, basicText);
      const p = u.player || {};
      const st = (p.state === 'playing' || p.state === 'paused' || p.state === 'idle') ? p.state : 'idle';
      const isAd = !!p.is_ad;
      // Pill coloring precedence: AD overrides other states
      let pillClass = 'user ' + (isAd ? 'ad' : st);
      setClass(row, pillClass);
      // Status icon
      const iconChar = st === 'playing' ? '▶' : (st === 'paused' ? '⏸' : '●');
      setText(iconEl, iconChar);
      setClass(iconEl, 'icon ' + (isAd ? 'ad' : st));
      // AD flag visibility
      adFlagEl.style.display = isAd ? '' : 'none';
      // Keep hidden state/badge minimal text for accessibility/debug
      const badgeClass = 'badge ' + (st === 'playing' ? 'playing' : (st === 'idle' ? 'idle' : ''));
      const badgeText = 'player: ' + st + (isAd ? ' (AD)' : '');
      setClass(badgeEl, badgeClass);
      setText(badgeEl, badgeText);
    }

    // Ensure order exactly matches input with minimal moves
    for (let i = 0; i < users.length; i++) {
      const u = users[i];
      const row = usersEl.querySelector('.user[data-user-id="' + String(u.id) + '"]');
      const target = usersEl.children[i];
      if (row && row !== target) usersEl.insertBefore(row, target || null);
    }

    if (users.length === 0 && !usersEl.querySelector('.sub')) {
      const empty = document.createElement('div'); empty.className = 'sub'; empty.textContent = 'No users'; usersEl.appendChild(empty);
    } else if (users.length > 0) {
      for (const sub of Array.from(usersEl.querySelectorAll('.sub'))) sub.remove();
    }
  }

  function updateQueue(card, room) {
    const queueWrap = card.querySelector('[data-role="queue"]');
    const qLabel = card.querySelector('[data-role="queueLabel"]');
    const entries = Array.isArray(room.entries) ? room.entries : [];
    const labelText = 'Queue ' + (room.queue && room.queue.id ? ('#' + room.queue.id) : '(none)') + ' · ' + entries.length + ' item' + (entries.length === 1 ? '' : 's');
    setText(qLabel, labelText);

    const present = new Set(entries.map(it => String(it.id)));
    for (const row of Array.from(queueWrap.querySelectorAll('.entry'))) {
      if (!present.has(String(row.dataset.entryId || ''))) row.remove();
    }

    for (const it of entries) {
      let row = queueWrap.querySelector('.entry[data-entry-id="' + String(it.id) + '"]');
      if (!row) {
        row = document.createElement('div'); row.className = 'entry'; row.dataset.entryId = String(it.id);
        const pos = document.createElement('div'); pos.className = 'chip'; pos.dataset.role = 'pos';
        const img = document.createElement('img'); img.className = 'thumb'; img.loading = 'lazy'; img.alt = ''; img.dataset.role = 'thumb';
        const meta = document.createElement('div'); meta.style.flex = '1 1 auto';
        const title = document.createElement('div'); title.className = 'entryTitle'; title.dataset.role = 'title';
        const url = document.createElement('div'); url.className = 'entryUrl'; url.dataset.role = 'url';
        meta.appendChild(title); meta.appendChild(url);
        row.appendChild(pos); row.appendChild(img); row.appendChild(meta);
        queueWrap.appendChild(row);
      }
      const posEl = row.querySelector('[data-role="pos"]');
      const imgEl = row.querySelector('[data-role="thumb"]');
      const titleEl = row.querySelector('[data-role="title"]');
      const urlEl = row.querySelector('[data-role="url"]');
      const dur = Number(it.duration || 0); const prog = Number(it.progress || 0); const ps = Number(it.playing_since || 0);
      setText(posEl, String(it.position == null ? 1 : it.position));
      if ((imgEl.getAttribute('src') || '') !== (it.thumbnail_url || '')) imgEl.src = it.thumbnail_url || '';
      const extra = (dur || prog || ps) ? (' · ' + (prog || 0) + 'ms/' + (dur || 0) + 'ms' + (ps ? (' · since ' + new Date(ps).toLocaleTimeString()) : '')) : '';
      setText(titleEl, (it.title || '(no title)') + extra);
      setText(urlEl, it.url || '');
    }

    // Keep order with minimal moves (account for header at index 0)
    const startIndex = 1; // header is first child
    for (let i = 0; i < entries.length; i++) {
      const it = entries[i];
      const row = queueWrap.querySelector('.entry[data-entry-id="' + String(it.id) + '"]');
      const target = queueWrap.children[startIndex + i];
      if (row && row !== target) queueWrap.insertBefore(row, target || null);
    }

    if (entries.length === 0 && !queueWrap.querySelector('.sub')) {
      const empty = document.createElement('div'); empty.className = 'sub'; empty.textContent = 'No entries'; queueWrap.appendChild(empty);
    } else if (entries.length > 0) {
      for (const sub of Array.from(queueWrap.querySelectorAll('.sub'))) sub.remove();
    }
  }

  function formatAuditText(a) {
    const ev = a.event;
    const d = a.details || {};
    const uname = a.user && a.user.name ? (a.user.name + ': ') : '';
    if (ev === 'state_change') {
      const from = d.from ? String(d.from) : undefined;
      const to = d.to ? String(d.to) : (d.state ? String(d.state) : undefined);
      const reason = d.reason ? (' · ' + d.reason) : '';
      return uname + 'state → ' + (to || '?') + (from ? (' (from ' + from + ')') : '') + reason;
    }
    if (ev === 'queue_add') return uname + 'queue · added: ' + (d.title || d.url || ('#' + (d.entry_id || '')));
    if (ev === 'queue_remove') return uname + 'queue · removed: ' + (d.title || d.url || ('#' + (d.entry_id || '')));
    if (ev === 'queue_skip') return uname + 'queue · skipped: ' + (d.title || d.url || ('#' + (d.entry_id || '')));
    if (ev === 'room_join') return uname + 'presence · user joined';
    if (ev === 'room_leave') return uname + 'presence · user left';
    if (ev === 'room_create') return uname + 'room · created';
    if (ev === 'ad_start') return uname + 'ads · ad started';
    if (ev === 'ad_end') return uname + 'ads · ad ended';
    if (ev === 'player_state') return uname + 'player → ' + (d.to || '?') + (d.from ? (' (from ' + d.from + ')') : '');
    return uname + ev;
  }

  function updateAudit(card, room) {
    const auditWrap = card.querySelector('[data-role="audit"]');
    const audits = Array.isArray(room.audits) ? room.audits : [];

    const present = new Set(audits.map(a => String(a.id)));
    for (const row of Array.from(auditWrap.querySelectorAll('.auditItem'))) {
      if (!present.has(String(row.dataset.auditId || ''))) row.remove();
    }

    for (const a of audits) {
      let row = auditWrap.querySelector('.auditItem[data-audit-id="' + String(a.id) + '"]');
      if (!row) {
        row = document.createElement('div'); row.className = 'auditItem'; row.dataset.auditId = String(a.id);
        const time = document.createElement('div'); time.className = 'auditTime'; time.dataset.role = 'time';
        const text = document.createElement('div'); text.className = 'auditText'; text.dataset.role = 'text';
        row.appendChild(time); row.appendChild(text);
        auditWrap.appendChild(row);
      }
      const timeEl = row.querySelector('[data-role="time"]');
      const textEl = row.querySelector('[data-role="text"]');
      const ts = a.created_at ? new Date(a.created_at * 1000) : null;
      const when = ts ? ts.toLocaleTimeString() : '';
      setText(timeEl, when);
      setText(textEl, formatAuditText(a));
    }

    // Ensure order matches audits array (already newest first)
    for (let i = 0; i < audits.length; i++) {
      const a = audits[i];
      const row = auditWrap.querySelector('.auditItem[data-audit-id="' + String(a.id) + '"]');
      const target = auditWrap.children[i];
      if (row && row !== target) auditWrap.insertBefore(row, target || null);
    }

    if (audits.length === 0 && !auditWrap.querySelector('.sub')) {
      const empty = document.createElement('div'); empty.className = 'sub'; empty.textContent = 'No audits'; auditWrap.appendChild(empty);
    } else if (audits.length > 0) {
      for (const sub of Array.from(auditWrap.querySelectorAll('.sub'))) sub.remove();
    }
  }

  function fmtTime(ms) {
    const total = Math.max(0, Math.floor((ms || 0) / 1000));
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = total % 60;
    const mm = h > 0 ? String(m).padStart(2, '0') : String(m);
    const ss = String(s).padStart(2, '0');
    return (h > 0 ? (h + ':' + mm + ':' + ss) : (m + ':' + ss));
  }

  function renderFromSocketState(socketState) {
    const container = document.getElementById('rooms');
    const rooms = socketState.rooms;

    const emptyId = 'rooms-empty';
    const existingCards = new Set(Array.from(container.querySelectorAll('.room')).map(el => el.dataset.code));
    const nextCodes = new Set(rooms.map(r => r.code));

    // Remove cards that disappeared
    for (const code of existingCards) {
      if (!nextCodes.has(code)) {
        const card = document.getElementById('room-' + code);
        if (card) card.remove();
      }
    }

    // Add/update cards and enforce order
    for (let i = 0; i < rooms.length; i++) {
      const room = rooms[i];
      const card = upsertRoomCard(container, room);
      updateRoomHeader(card, room);
      updateUsers(card, room);
      updateQueue(card, room);
      updateAudit(card, room);
      const target = container.children[i];
      if (card !== target) container.insertBefore(card, target || null);
    }

    // Empty state
    let empty = document.getElementById(emptyId);
    if (rooms.length === 0) {
      if (!empty) {
        empty = document.createElement('div'); empty.id = emptyId; empty.className = 'panel'; empty.style.padding = '16px'; empty.textContent = 'No active rooms';
        container.appendChild(empty);
      }
    } else if (empty) {
      empty.remove();
    }
  }
  async function controlRoom(code, action, arg, arg2) {
    try {
      if (!code || !window._sock) return;
      if (action === 'play') {
        _sock.emit('room_state_set', { code, state: 'playing' });
      } else if (action === 'pause') {
        _sock.emit('room_state_set', { code, state: 'idle' });
      } else if (action === 'next') {
        _sock.emit('vote_skip', { code });
      } else if (action === 'seek') {
        const progress_ms = Math.max(0, Number(arg || 0));
        const play = !!arg2;
        _sock.emit('room_seek', { code, progress_ms, play });
      }
    } catch (e) { console.warn('controlRoom failed', e); }
  }

  function boot() {
    const socketState = { rooms: [] };
    const presenceMap = {}; // code -> last presence payload
    const queuesMap = {};   // code -> { queue, items }
    const playbackMap = {}; // code -> last playback payload
    const roomStateMap = {}; // code -> state
    const auditsMap = {}; // code -> array
    let selectedCode = null;
    function renderSidebar(roomsList) {
      const wrap = document.getElementById('sidebarRooms');
      if (!wrap) return;
      wrap.innerHTML = '';
      for (const r of roomsList) {
        const row = document.createElement('div'); row.className = 'roomRow'; row.dataset.code = r.code;
        const left = document.createElement('div');
        const code = document.createElement('div'); code.className = 'code'; code.textContent = r.code;
        const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = (r.active_count || 0) + ' users · ' + (r.state || 'idle');
        left.appendChild(code); left.appendChild(meta);
        const btn = document.createElement('button'); btn.className = 'joinBtn'; btn.type = 'button'; btn.textContent = 'Join';
        btn.addEventListener('click', () => { try { selectedCode = r.code; if (window._sock) { window._sock.emit('ops_room_subscribe', { code: r.code }); } recomputeRooms(); } catch { } });
        row.appendChild(left); row.appendChild(btn);
        wrap.appendChild(row);
      }
    }
    function recomputeRooms() {
      const codes = Array.from(new Set([].concat(
        Object.keys(presenceMap),
        Object.keys(queuesMap),
        Object.keys(playbackMap),
        Object.keys(roomStateMap)
      ))).sort();
      const allRooms = codes.map(code => {
        const users = (presenceMap[code] || {}).members || [];
        const q = (queuesMap[code] || {}).queue || null;
        const items = (queuesMap[code] || {}).items || [];
        const pb = playbackMap[code] || null;
        // Merge playback timing into first entry so seek bar reflects live baseline
        if (pb && pb.entry) {
          if (items.length > 0) {
            try {
              items[0] = Object.assign({}, items[0], {
                duration: Number(pb.entry.duration || 0),
                progress: Number(pb.entry.progress || 0),
                playing_since: Number(pb.entry.playing_since || 0)
              });
            } catch { }
          } else {
            items.push({
              id: pb.entry.id || 0,
              url: '', title: '', thumbnail_url: '', position: 1,
              duration: Number(pb.entry.duration || 0),
              progress: Number(pb.entry.progress || 0),
              playing_since: Number(pb.entry.playing_since || 0)
            });
          }
        }
        const state = (pb && pb.state) ? pb.state : (roomStateMap[code] || 'idle');
        return {
          code,
          state,
          users,
          queue: q,
          entries: items,
          audits: (auditsMap[code] || []).slice(0, 50)
        };
      });
      // If a room is selected, show only that room in the main panel; otherwise show all
      socketState.rooms = selectedCode ? allRooms.filter(r => r.code === selectedCode) : allRooms;
      renderFromSocketState(socketState);
    }
    window.refreshRoom = function (code) {
      try {
        if (!window._sock || !code) return;
        // Re-subscribe to force emitting fresh snapshots to this SID
        window._sock.emit('ops_room_subscribe', { code });
      } catch { }
    };
    try {
      const qs = new URLSearchParams(location.search);
      const token = qs.get('token') || (localStorage.getItem('dash_token') || '');
      if (token) localStorage.setItem('dash_token', token);
      const base = location.origin;
      const sock = io(base, { transports: ['websocket'], path: '/socket.io', query: { token } });
      window._sock = sock;
      // Identity handshake
      sock.on('hello', (payload) => {
        try {
          const user = payload && payload.user ? payload.user : null;
          const isOps = !!(payload && payload.ops);
          if (window.__setIdentityUI) window.__setIdentityUI(user, isOps);
        } catch {}
      });
      sock.on('connect', () => { try { console.log('dashboard socket connected'); } catch { } });
      sock.on('disconnect', () => { try { console.log('dashboard socket disconnected'); } catch { } });
      sock.on('room_presence', (p) => { if (p && p.code) { presenceMap[p.code] = p; recomputeRooms(); } });
      sock.on('queue_snapshot', (p) => { if (p && p.code) { queuesMap[p.code] = { queue: { id: 0 }, items: Array.isArray(p.items) ? p.items : [] }; recomputeRooms(); } });
      sock.on('room_state_change', (p) => { if (p && p.code) { roomStateMap[p.code] = p.state || 'idle'; recomputeRooms(); } });
      sock.on('room_playback', (p) => { if (p && p.code) { playbackMap[p.code] = p; if (p.state) roomStateMap[p.code] = p.state; recomputeRooms(); } });
      // When presence arrives for a room we haven't seen, auto-subscribe to get queue/playback immediately
      sock.on('room_presence', (p) => {
        if (p && p.code) {
          if (!presenceMap[p.code]) {
            try { sock.emit('ops_room_subscribe', { code: p.code }); } catch { }
          }
          presenceMap[p.code] = p; recomputeRooms();
        }
      });
      // Sidebar: request active rooms list frequently
      sock.on('ops_rooms_list', (payload) => { try { const rooms = (payload && Array.isArray(payload.rooms)) ? payload.rooms : []; renderSidebar(rooms); } catch { } });
      setInterval(() => { try { sock.emit('ops_rooms_list', {}); } catch { } }, 2000);
      // Allow manual monitor joins via code input (does not need to be in presence)
      const btn = document.getElementById('roomAddBtn');
      const input = document.getElementById('roomCodeInput');
      if (btn && input) {
        btn.addEventListener('click', () => {
          const code = (input.value || '').trim();
          if (!code) return;
          // Request targeted snapshots to populate maps
          try { sock.emit('ops_room_subscribe', { code }); } catch { }
          // Immediately create empty shells so card appears
          if (!presenceMap[code]) presenceMap[code] = { code, members: [] };
          selectedCode = code; recomputeRooms();
        });
      }
    } catch (e) { console.warn('socket.io not available', e); }
    // Local ticker to smooth seek bars between SSE updates
    setInterval(() => {
      try {
        const cards = Array.from(document.querySelectorAll('.room'));
        for (const card of cards) {
          const pill = card.querySelector('[data-role="pill"]');
          const isPlaying = !!(pill && pill.className && pill.className.indexOf('playing') !== -1 && pill.className.indexOf('playing_ad') === -1);
          const range = card.querySelector('[data-role="seekRange"]');
          const curEl = card.querySelector('[data-role="cur"]');
          const durEl = card.querySelector('[data-role="dur"]');
          if (!range || !range._meta) continue;
          const meta = range._meta; const dur = Number(meta.dur || 0); const prog = Number(meta.prog || 0); const ps = Number(meta.ps || 0);
          const now = Date.now();
          let curMs = prog || 0;
          if (isPlaying && ps > 0) curMs = Math.min(dur || Infinity, (prog || 0) + Math.max(0, now - ps));
          if (!range._dragging) {
            const pct = dur > 0 ? Math.max(0, Math.min(1000, Math.floor((curMs / dur) * 1000))) : 0;
            range.value = String(pct);
            if (curEl) curEl.textContent = fmtTime(curMs);
            if (durEl) durEl.textContent = fmtTime(dur);
          } else {
            // While dragging, label follows thumb
            const ms = Math.floor((Number(range.value || '0') / 1000) * (dur || 0));
            if (curEl) curEl.textContent = fmtTime(ms);
            if (durEl) durEl.textContent = fmtTime(dur);
          }
        }
      } catch { }
    }, 250);
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot);
  } else { boot(); }
</script>
{% endblock %}